<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SCF Circle Packing Relationship Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/treeselectjs@0.11.0/dist/treeselectjs.umd.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/treeselectjs@0.11.0/dist/treeselectjs.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="scf_processor.js"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;700&family=Inter:wght@300;400;500;600&display=swap"
        rel="stylesheet">
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        deep: '#030712',
                    }
                }
            }
        }
    </script>
    <style>
        :root {
            /* Default Light Theme */
            --bg-deep: #f8fafc;
            /* Light gray background */
            --sidebar-color: #ffffff;
            --sidebar-darker: #f1f5f9;
            --accent-blue: #3b82f6;
            --accent-indigo: #6366f1;

            /* Text & Borders */
            --text-primary: #1e293b;
            /* Dark text for light mode */
            --text-muted: #64748b;
            --border-muted: rgba(0, 0, 0, 0.1);
            --border-faint: rgba(0, 0, 0, 0.05);

            /* Treeselect overrides */
            --ts-bg: var(--sidebar-darker);
            --ts-list-bg: var(--sidebar-color);
            --ts-tag-blue: #3b82f6;
            --ts-tag-indigo: #6366f1;

            /* Visualization Colors */
            /* Visualization Colors */
            --label-color: #0f172a;
            --node-stroke: rgba(0, 0, 0, 0.4);
            --node-stroke-hover: #1e293b;
            --node-shadow-text: none;
            --node-fill-default: rgba(0, 0, 0, 0.05);
            --control-fill: rgba(0, 0, 0, 0.1);

            /* Greyscale for SCF Layers */
            --scf-depth-1: #94a3b8;
            /* Slate 400 */
            --scf-depth-2: #cbd5e1;
            /* Slate 300 */
            --scf-depth-3: #e2e8f0;
            /* Slate 200 */
            --scf-depth-4: #f1f5f9;
            /* Slate 100 */
        }

        .dark {
            /* Dark Theme Overrides */
            --bg-deep: #030712;
            --sidebar-color: #111827;
            --sidebar-darker: #0f172a;

            --text-primary: #f3f4f6;
            --text-muted: #94a3b8;
            --border-muted: rgba(255, 255, 255, 0.1);
            --border-faint: rgba(255, 255, 255, 0.05);

            /* Treeselect overrides (Dark) */
            --ts-bg: #0f172a;
            --ts-list-bg: #111827;
            --ts-tag-blue: #1e3a8a;
            --ts-tag-indigo: #312e81;

            /* Visualization Colors (Dark) */
            --label-color: #fff;
            --node-stroke: rgba(255, 255, 255, 0.1);
            --node-stroke-hover: #fff;
            --node-shadow-text: 0 1px 4px rgba(0, 0, 0, 0.9), 0 0 10px rgba(0, 0, 0, 0.5);
            --node-fill-default: rgba(255, 255, 255, 0.02);
            --control-fill: rgba(255, 255, 255, 0.15);

            /* Greyscale for SCF Layers (Dark Mode) */
            --scf-depth-1: rgba(255, 255, 255, 0.15);
            --scf-depth-2: rgba(255, 255, 255, 0.10);
            --scf-depth-3: rgba(255, 255, 255, 0.05);
            --scf-depth-4: rgba(255, 255, 255, 0.20);
            /* Control highlight */
        }

        body {
            background-color: var(--bg-deep);
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            margin: 0;
        }

        h1,
        h2,
        h3 {
            font-family: 'Outfit', sans-serif;
        }

        .glass {
            background: var(--sidebar-color);
            backdrop-filter: blur(16px);
            border: 1px solid var(--border-muted);
            color: var(--text-primary);
        }

        /* Adjust glass color transparency for dark mode via variable or specificity */
        .dark .glass {
            background: rgba(17, 24, 39, 0.9);
        }

        .node {
            cursor: pointer;
            transition: stroke 0.2s, stroke-width 0.2s, fill 0.3s;
        }

        .node--1 {
            stroke: var(--accent-blue);
            stroke-opacity: 0.4;
            stroke-width: 1px;
            fill: var(--accent-blue);
            fill-opacity: 0.05;
        }

        .node--2 {
            stroke: var(--node-stroke);
            stroke-width: 0.5px;
            fill: var(--node-fill-default);
        }

        .node--3 {
            stroke: var(--node-stroke);
            stroke-width: 0.5px;
            fill: var(--node-fill-default);
            fill-opacity: 0.5;
            /* Slightly fainter */
        }

        .node:hover {
            stroke: var(--node-stroke-hover) !important;
            stroke-width: 2px !important;
        }

        .label {
            fill: var(--label-color);
            pointer-events: none;
            text-anchor: middle;
            font-family: 'Outfit', sans-serif;
            transition: fill-opacity 0.3s, font-size 0.3s, transform 0.5s, fill 0.3s;
            text-shadow: var(--node-shadow-text);
            letter-spacing: -0.01em;
        }

        /* Sidebar Accordion */
        .accordion-header {
            @apply flex items-center justify-between p-4 cursor-pointer hover:bg-white/5 transition-colors border-b border-white/5;
        }

        .accordion-content {
            @apply overflow-hidden transition-all duration-300;
        }

        .accordion-item.open .accordion-content {
            overflow: visible !important;
        }

        /* --- Unified Treeselect Overrides --- */
        .treeselect-input {
            background: var(--ts-bg) !important;
            border: 1px solid var(--border-muted) !important;
            border-radius: 0.75rem !important;
            color: var(--text-primary) !important;
            min-height: 38px !important;
        }

        .treeselect-input__edit {
            background: transparent !important;
            color: var(--text-primary) !important;
            font-size: 13px !important;
            max-width: 100% !important;
            position: relative !important;
            z-index: 1 !important;
        }

        .treeselect-input__edit::placeholder {
            color: rgba(255, 255, 255, 0.4) !important;
        }

        .treeselect-list {
            background: var(--ts-list-bg) !important;
            border: 1px solid var(--border-muted) !important;
            border-radius: 0.75rem !important;
            z-index: 100 !important;
        }

        .treeselect-input__tags-name {
            margin-left: 7px !important;
            margin-right: 3px !important;
            margin-top: 3px !important;
            margin-bottom: 2px !important;
        }

        /* Inline behavior for sidebar accordions */
        .accordion-content .treeselect-list {
            position: relative !important;
            border: none !important;
            box-shadow: none !important;
            margin-top: 0 !important;
            max-height: 450px !important;
            background: var(--sidebar-color) !important;
        }

        /* Tags Design */
        .treeselect-input__tags-element {
            background: var(--ts-tag-blue) !important;
            color: #ffffff !important;
            border-radius: 6px !important;
            padding: 2px 8px !important;
            margin: 2px !important;
            font-weight: 600 !important;
            border: 1px solid var(--accent-blue) !important;
            height: auto !important;
        }

        #hierarchy-fields-treeselect .treeselect-input__tags-element {
            background: var(--ts-tag-indigo) !important;
            border-color: var(--accent-indigo) !important;
        }

        .treeselect-input__tags-name {
            font-size: 11px !important;
        }

        .treeselect-input__tags-cross svg {
            stroke: #fff !important;
            opacity: 0.6;
        }

        /* List Items & Styling */
        .treeselect-list__item {
            color: var(--text-muted) !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            padding-right: 12px !important;
            /* Do NOT override padding-left with !important */
            height: 32px !important;
        }

        .treeselect-list__item--focused,
        .treeselect-list__item:hover {
            background: var(--accent-blue) !important;
            color: #fff !important;
        }

        .treeselect-list__item--checked,
        .treeselect-list__item--single-selected {
            background: rgba(59, 130, 246, 0.15) !important;
            color: #60a5fa !important;
            font-weight: 600 !important;
        }

        .treeselect-list__item-label {
            font-size: 13px !important;
        }

        /* Checkboxes */
        .treeselect-list__item-checkbox-container {
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
            background: var(--bg-deep) !important;
            width: 16px !important;
            height: 16px !important;
            min-width: 16px !important;
        }

        .treeselect-list__item--checked .treeselect-list__item-checkbox-container,
        .treeselect-list__item--partial-checked .treeselect-list__item-checkbox-container {
            background-color: var(--accent-blue) !important;
            border-color: var(--accent-blue) !important;
        }

        /* Icons */
        .treeselect-input__arrow svg,
        .treeselect-input__clear svg {
            stroke: rgba(255, 255, 255, 0.4) !important;
        }

        .treeselect-input__tags-element {
            margin: 0 !important;
            padding: 0 !important;
        }

        .hidden-panel {
            transform: translateX(120%) !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* Footer Branding */
        select option {
            background-color: var(--sidebar-color);
            color: var(--text-primary);
        }

        footer {
            font-size: 0.55rem;
            color: rgba(156, 163, 175, 0.4);
            white-space: nowrap;
            transition: color 0.3s ease;
        }

        footer:hover {
            color: rgba(255, 255, 255, 0.9);
        }

        footer a {
            color: inherit;
            text-decoration: none;
            font-weight: 500;
        }

        footer a:hover {
            color: #60a5fa;
            text-decoration: underline;
        }

        footer img {
            filter: grayscale(1) invert(0.8);
            opacity: 0.3;
            transition: all 0.3s ease;
            display: inline-block;
            vertical-align: middle;
        }

        footer:hover img {
            filter: grayscale(0) invert(0);
            opacity: 1;
        }

        aside {
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 40;
            /* Above main content */
        }

        .left-sidebar {
            transform: translateX(0);
        }

        .left-sidebar.collapsed {
            transform: translateX(-100%);
        }

        #right-sidebar {
            transform: translateX(100%);
        }

        #right-sidebar.open {
            transform: translateX(0);
        }

        /* Unified Toggle Handle Style */
        .sidebar-handle {
            position: absolute;
            top: 50%;
            width: 32px;
            height: 64px;
            background: rgba(17, 24, 39, 0.9);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #94a3b8;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 50;
        }

        .sidebar-handle:hover {
            color: #fff;
            background: #1f2937;
        }

        /* Specific positions */
        .left-sidebar .sidebar-handle {
            right: -32px;
            /* Outside right edge */
            border-left: none;
            border-radius: 0 8px 8px 0;
            box-shadow: 4px 0 15px rgba(0, 0, 0, 0.3);
        }

        #right-sidebar .sidebar-handle {
            left: -32px;
            /* Outside left edge */
            border-right: none;
            border-radius: 8px 0 0 8px;
            box-shadow: -4px 0 15px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>

<body class="flex h-screen w-full">
    <!-- Sidebar -->
    <aside id="left-sidebar" class="left-sidebar glass w-80 h-full flex flex-col border-r z-20 shadow-2xl relative">
        <button class="sidebar-handle" onclick="toggleSidebar()" title="Toggle Sidebar">
            <span id="toggle-icon">‚óÄ</span>
        </button>
        <div class="p-6 border-b border-white/10">
            <h1 class="text-xl font-bold bg-gradient-to-r from-blue-400 to-indigo-400 bg-clip-text text-transparent">
                SCF Visualizer
            </h1>
            <p class="text-[10px] text-gray-500 mt-1 uppercase tracking-tighter">Zoomable Relationship Engine</p>
        </div>

        <div class="flex-1 flex flex-col overflow-hidden">
            <!-- Regime Selector -->
            <div id="regime-item" class="accordion-item border-b border-white/10 open">
                <div class="accordion-header" onclick="toggleAccordion('regime-selector')">
                    <span class="text-sm font-semibold flex items-center gap-2">
                        üõ°Ô∏è Compliance Regimes
                    </span>
                </div>
                <div id="regime-selector" class="accordion-content p-4 overflow-y-auto" style="max-height: 40vh;">
                    <div id="treeselect-container" class="w-full"></div>
                </div>
            </div>

            <!-- Hierarchy Fields Accordion -->
            <div class="accordion-item border-b border-white/10 open">
                <div class="accordion-header" onclick="toggleAccordion('hierarchy-fields-container')">
                    <span class="text-sm font-semibold flex items-center gap-2">
                        üèóÔ∏è Hierarchy Fields
                    </span>
                </div>
                <div id="hierarchy-fields-container" class="accordion-content p-4 overflow-y-auto"
                    style="max-height: 30vh;">
                    <div id="hierarchy-fields-treeselect" class="w-full"></div>
                    <div class="mt-2 text-[10px] text-gray-500 italic px-2 leading-tight text-indigo-400/60">
                        * Selection order defines hierarchical depth
                    </div>
                </div>
            </div>

            <!-- Control Navigator Accordion (MOVED TO RIGHT) -->
        </div>

        <!-- Footer Branding -->
        <div class="px-4 py-2 border-t border-white/5 bg-white/5 dark:bg-black/40">
            <div class="mb-2 flex items-center justify-between">
                <label
                    class="text-[10px] font-semibold text-gray-500 dark:text-gray-400 uppercase cursor-pointer flex items-center gap-2 hover:text-black dark:hover:text-white transition-colors">
                    <input type="checkbox" id="toggle-unmapped" checked
                        class="w-3.5 h-3.5 rounded bg-white/5 border-white/10 text-blue-500 focus:ring-offset-0 focus:ring-0 checked:bg-blue-600"
                        onchange="toggleUnmappedVisibility(this.checked)">
                    Show unmapped
                </label>

                <!-- Theme Switcher -->
                <select id="theme-select" onchange="setTheme(this.value)"
                    class="bg-white/10 dark:bg-black/20 border border-black/10 dark:border-white/10 rounded text-[10px] text-gray-600 dark:text-gray-400 px-1 py-0.5 focus:outline-none focus:border-blue-500">
                    <option value="system">System</option>
                    <option value="dark">Dark</option>
                    <option value="light">Light</option>
                </select>
            </div>
            <footer>
                <a href="https://github.com/securecontrolsframework/securecontrolsframework" target="_blank">SCF
                    Visualizer</a> ¬© 2026
                <span class="mx-1 opacity-20">|</span>
                <a href="https://www.linkedin.com/in/drew-gutstein-9332b34/" target="_blank">Drew Gutstein</a>
                <span class="mx-1 opacity-20">|</span>
                <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>
                <span class="inline-flex gap-0.5 ml-1 transform translate-y-0.5">
                    <img src="https://mirrors.creativecommons.org/presskit/icons/cc.svg" alt="CC" class="h-2 w-2">
                    <img src="https://mirrors.creativecommons.org/presskit/icons/by.svg" alt="BY" class="h-2 w-2">
                </span>
            </footer>
        </div>
    </aside>

    <!-- Main Visualization Panel -->
    <main class="flex-grow relative h-screen overflow-hidden">
        <!-- Header Status -->

        <div id="viz-container" class="w-full h-full"></div>

        <!-- Legend Overlay -->
        <div id="regime-legend" class="absolute bottom-8 right-8 flex flex-col gap-2 pointer-events-none">
            <!-- Selected regime colors show here -->
        </div>

        <!-- Breadcrumbs -->
        <div id="breadcrumbs" class="absolute top-6 left-6 z-20 text-xs text-gray-500 font-mono shadow-sm flex gap-2">
            <!-- Path updates here -->
        </div>
    </main>

    <!-- Right Sidebar for Navigation & Details -->
    <aside id="right-sidebar"
        class="fixed top-0 right-0 h-full w-96 glass z-30 shadow-2xl flex flex-col border-l border-white/10">
        <!-- Unified Handle (Inside) -->
        <button onclick="toggleRightSidebar()" class="sidebar-handle">
            <span id="right-toggle-icon">‚óÄ</span>
        </button>

        <!-- Right Header -->
        <div class="p-4 border-b border-white/10 flex justify-between items-center bg-white/5">
            <h2 class="font-bold text-sm tracking-widest uppercase">Inspect & Navigate</h2>
        </div>

        <!-- Navigator Section (Top Half) -->
        <div class="flex-1 flex flex-col min-h-0 border-b border-white/10">
            <div
                class="p-2 bg-white/5 text-[10px] font-bold uppercase tracking-wider text-gray-500 flex items-center gap-2">
                <span>üìÇ Hierarchy Navigator</span>
            </div>
            <div id="hierarchy-navigator-treeselect" class="p-4 flex-1 overflow-y-auto"></div>
        </div>

        <!-- Details Section (Bottom Half) -->
        <div id="detail-panel-content" class="flex-1 flex flex-col min-h-0 bg-white/5 dark:bg-black/20">
            <div id="detail-empty" class="h-full flex flex-col items-center justify-center opacity-20 text-center">
                <span class="text-4xl mb-4">üîç</span>
                <p class="text-xs">Select a control bubble<br>to view deep analytics</p>
            </div>
            <div id="detail-data" class="hidden p-6 overflow-y-auto space-y-6">
                <div>
                    <span id="detail-id"
                        class="text-blue-500 font-mono text-xs font-bold uppercase tracking-widest"></span>
                    <h3 id="detail-title" class="text-2xl font-bold mt-2 leading-tight"></h3>
                    <p id="detail-domain" class="text-[10px] text-gray-500 mt-1 uppercase italic"></p>
                </div>

                <div class="bg-white/5 rounded-xl p-5 border border-white/10">
                    <h4 class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-3">Functional Summary
                    </h4>
                    <p id="detail-desc" class="text-sm text-gray-300 leading-relaxed"></p>
                </div>

                <div class="grid grid-cols-2 gap-4">
                    <div class="bg-blue-500/5 rounded-xl p-4 border border-blue-500/10 active-highlight">
                        <span class="text-[9px] text-blue-400 font-bold uppercase block mb-1">Impact Weight</span>
                        <span id="detail-weight" class="text-xl font-bold font-mono"></span>
                    </div>
                    <div class="bg-indigo-500/5 rounded-xl p-4 border border-indigo-500/10">
                        <span class="text-[9px] text-indigo-400 font-bold uppercase block mb-1">Domain Focus</span>
                        <span id="detail-pptdf" class="text-xl font-bold"></span>
                    </div>
                </div>

                <div>
                    <h4 class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-4">Mapped Ecosystem</h4>
                    <div id="detail-mappings" class="space-y-3">
                        <!-- Mappings rendered as bars -->
                    </div>
                </div>
            </div>
        </div>
    </aside>

    <script>
        // State
        const DEFAULT_REGIMES = [62, 167, 226]; // CSF 2.0, EU DORA, India SEBI CSCRF
        let selectedRegimeIds = new Set();
        let labelDetailLevels = 2; // Hardcoded to 2 levels as requested

        // Load from localStorage or use defaults
        const savedRegimes = localStorage.getItem('scf_selected_regimes');
        if (savedRegimes) {
            try {
                selectedRegimeIds = new Set(JSON.parse(savedRegimes));
            } catch (e) {
                selectedRegimeIds = new Set(DEFAULT_REGIMES);
            }
        } else {
            selectedRegimeIds = new Set(DEFAULT_REGIMES);
        }
        let showUnmapped = true;
        let root;
        let hierarchyFieldsTreeselect;
        let hierarchyNavigatorTreeselect;
        let regimeTreeselect;
        let scfData; // Globally available after processing
        const HIERARCHY_ALIASES = {
            "PPTDF_Applicability": "pptd",
            "NIST_CSF_Function_Grouping": "nist",
            "SCF_Domain": "domain",
            "Conformity_Validation_Cadence": "cadent",
            "Relative_Control_Weighting": "weight"
        };
        const REVERSE_ALIASES = Object.fromEntries(Object.entries(HIERARCHY_ALIASES).map(([k, v]) => [v, k]));

        let processor = new SCFDataProcessor();
        let svg, g, node, label;
        let width, height;
        let d3Zoom;
        let focus, view;
        const colors = d3.scaleOrdinal(d3.schemeTableau10);
        const typeColors = {
            "People": "#f43f5e",
            "Process": "#3b82f6",
            "Technology": "#a855f7",
            "Data": "#10b981",
            "Facility": "#f59e0b",
            "Standard": "#6b7280"
        };
        const getRegimeColor = (rid) => colors(rid);

        // Helper functions for dynamic labeling (Relative to focus)
        const getLabelSize = (d, currentFocus, isHovered = false) => {
            if (isHovered) return "16px";
            return "14px"; // Consistent size regardless of depth
        };

        const getLabelOffset = (d, r, currentFocus) => {
            const depthDiff = d.depth - (currentFocus?.depth || 0);
            // Only top-anchor the Focus node (Header) to keep center clear for primary children
            if (depthDiff === 0 && d.children && d.children.length > 0) return -r * 0.9;
            return 0;
        };

        const getLabelOpacity = (d, currentFocus, isHovered = false) => {
            if (isHovered) return 1;
            const depthDiff = d.depth - (currentFocus?.depth || 0);
            if (depthDiff === 0) return 0.8; // Focus is prominent but slightly transparent as a background
            if (depthDiff === 1) return 0.7; // Children are visible
            return 0;
        };

        const getLabelDisplay = (d, currentFocus) => {
            const depthDiff = d.depth - (currentFocus?.depth || 0);
            return (depthDiff === 0 || depthDiff === 1) ? "inline" : "none";
        };

        function refreshLabelContent(currentFocus) {
            if (!label) return;
            label.each(function (d) {
                const node = d3.select(this);
                const depthDiff = d.depth - currentFocus.depth;
                const name = d.data.name.split(':')[0];

                node.text(""); // Clear

                if (depthDiff === 0) {
                    // Focus Header: Name only
                    node.append("tspan").style("font-weight", "700").text(name);
                } else if (depthDiff === 1) {
                    // Children: % + Name
                    const pct = Math.round((d.value / currentFocus.value) * 100);
                    node.append("tspan")
                        .style("opacity", "0.7")
                        .style("font-weight", "400")
                        .text(`${pct}% `);
                    node.append("tspan").text(name);
                }
            });
        }

        // --- D3 Initialization ---
        function initViz() {
            const container = document.getElementById('viz-container');
            width = container.clientWidth;
            height = container.clientHeight;

            d3.select("#viz-container").selectAll("svg").remove();

            svg = d3.select("#viz-container").append("svg")
                .attr("viewBox", `-${width / 2} -${height / 2} ${width} ${height}`)
                .style("display", "block")
                .style("background", "transparent")
                .style("cursor", "pointer")
                .on("click", (event) => {
                    zoom(event, root);
                    closeDetails(); // Close panel when clicking background
                });

            g = svg.append("g");
            updateVisualization();
        }

        function updateVisualization() {
            if (!scfData) return;

            // Re-build hierarchy based on selection
            const filteredData = filterData(JSON.parse(JSON.stringify(scfData)));

            if (!filteredData || !filteredData.children || filteredData.children.length === 0) {
                g.selectAll("*").remove();
                g.append("text")
                    .attr("text-anchor", "middle")
                    .attr("fill", "rgba(255,255,255,0.2)")
                    .style("font-size", "14px")
                    .text("No regimes selected or no matching controls found.");
                return;
            }

            const pack = data => d3.pack()
                .size([width, height])
                .padding(d => d.depth === 1 ? 5 : 2)
                (d3.hierarchy(data)
                    .sum(d => d.value || (d.weight ? d.weight * 5 : 1))
                    .sort((a, b) => (b.value || b.weight || 0) - (a.value || a.weight || 0)));

            root = pack(filteredData);
            focus = root;

            // Assign unique persistent IDs for this render to ensure Treeselect values are stable
            root.descendants().forEach((d, i) => d.id = "node-" + i);

            // Re-sync the navigator options
            if (typeof initHierarchyNavigatorTreeselect === 'function') {
                initHierarchyNavigatorTreeselect();
            }

            // Initialize Pan/Zoom on the SVG
            setupPanZoom();

            // Update hierarchy sidebar to match the D3 tree
            setupHierarchyNavigator();

            g.selectAll("*").remove();

            node = g.append("g")
                .selectAll("circle")
                .data(root.descendants().slice(1))
                .join("circle")
                .attr("class", d => `node node--${d.depth} ${d.children ? "" : "node--leaf"}`)
                .style("fill", d => {
                    if (d.depth === 1) return "var(--scf-depth-1)";
                    if (d.depth === 2) return "var(--scf-depth-2)";
                    if (d.depth === 3) return "var(--scf-depth-3)";
                    if (d.depth === 4) return "var(--scf-depth-4)";
                    if (d.depth === 5) return getRegimeColor(d.data.regimeId);
                    if (d.depth === 6) return getRegimeColor(d.data.regimeId);
                    return "var(--node-fill-default)";
                })
                .style("fill-opacity", d => {
                    if (d.depth === 5) return 0.2; // Manual opacity for regime groups
                    return d.children ? 0.4 : 0.8;
                })
                .style("stroke", d => d.children ? "var(--node-stroke)" : "transparent")
                .style("stroke-width", 0.5)
                .on("mouseover", function (event, d) {
                    d3.select(this)
                        .style("stroke", "var(--node-stroke-hover)")
                        .style("stroke-width", d.depth === 4 ? "3px" : "2px");
                    // Search and Enlarge Label
                    label.filter(l => l === d)
                        .transition().duration(200)
                        .style("display", "inline")
                        .style("fill-opacity", 1)
                        .style("font-size", getLabelSize(d, focus, true))
                        .style("font-weight", 700);
                })
                .on("mouseout", function (event, d) {
                    d3.select(this)
                        .style("stroke", d.children ? "var(--node-stroke)" : "transparent")
                        .style("stroke-width", "0.5px");
                    // Restore Label
                    label.filter(l => l === d)
                        .transition().duration(200)
                        .style("display", getLabelDisplay(d, focus))
                        .style("fill-opacity", getLabelOpacity(d, focus))
                        .style("font-size", getLabelSize(d, focus))
                        .style("font-weight", d => {
                            const depthDiff = d.depth - focus.depth;
                            return (depthDiff === 0) ? "700" : "400";
                        });
                })
                .on("click", (event, d) => {
                    if (focus !== d) {
                        zoom(event, d);
                        event.stopPropagation();
                    }
                    // Walk up to find the nearest control node (Depth 4 or has mappings)
                    const controlNode = d.ancestors().find(a => a.data.mappings);
                    if (controlNode) {
                        showDetails(controlNode.data);
                    } else {
                        closeDetails();
                    }
                });

            label = g.append("g")
                .attr("pointer-events", "none")
                .attr("text-anchor", "middle")
                .selectAll("text")
                .data(root.descendants().sort((a, b) => b.depth - a.depth))
                .join("text")
                .attr("class", "label");

            refreshLabelContent(root);

            // Set initial state
            label.style("font-size", d => getLabelSize(d, root))
                .style("fill-opacity", d => getLabelOpacity(d, root))
                .style("display", d => getLabelDisplay(d, root));

            updateBreadcrumbs(root);
            zoomTo([root.x, root.y, root.r * 2]);

            window.externalZoom = (d) => {
                // Focus based zoom
                zoom({ stopPropagation: () => { } }, d);
            };

            // Manual Pan/Zoom Logic (Inertia/Standard D3 Zoom)
            function setupPanZoom() {
                d3Zoom = d3.zoom()
                    .scaleExtent([0.1, 40])
                    .on("zoom", (event) => {
                        g.attr("transform", event.transform);
                    });

                // Only enable pan/zoom on the background to avoid fighting with focused zooming
                svg.call(d3Zoom)
                    .on("dblclick.zoom", null);
            }
            window.zoomReset = () => {
                svg.transition().duration(750).call(d3Zoom.transform, d3.zoomIdentity);
                window.externalZoom(root);
            };
        }

        function zoomTo(v) {
            if (!label || !node) return;
            const k = width / v[2];
            view = v;
            label.attr("transform", d => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k + getLabelOffset(d, d.r * k, focus)})`);
            node.attr("transform", d => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`);
            node.attr("r", d => d.r * k);
        }

        function zoom(event, d) {
            focus = d;
            const transition = svg.transition()
                .duration(750)
                .tween("zoom", d => {
                    const i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2]);
                    return t => zoomTo(i(t));
                });

            refreshLabelContent(focus);
            updateURL();

            label.transition(transition)
                .style("fill-opacity", d => getLabelOpacity(d, focus))
                .style("font-size", d => getLabelSize(d, focus))
                .on("start", function (d) {
                    if (getLabelDisplay(d, focus) === "inline") this.style.display = "inline";
                })
                .on("end", function (d) {
                    if (getLabelDisplay(d, focus) === "none") this.style.display = "none";
                });

            updateBreadcrumbs(d);
        }

        function setupHierarchyNavigator() {
            if (!root) return;

            // Build Treeselect options recursively from the D3 tree
            function buildOptions(d3Node) {
                const name = d3Node.data.name || "Uncategorized";
                const isControl = !!d3Node.data.mappings;

                const option = {
                    name: name,
                    value: d3Node.id, // Use the persistent D3 ID
                    children: null
                };

                // Stop recurring at controls to avoid showing mapping IDs (depth 5) in sidebar
                if (!isControl && d3Node.children && d3Node.children.length > 0) {
                    const mappedChildren = d3Node.children
                        .map(c => buildOptions(c))
                        .filter(opt => opt !== null);
                    if (mappedChildren.length > 0) {
                        option.children = mappedChildren;
                    }
                }
                return option;
            }

            // Map top-level domains, starting with the root node itself
            const options = [buildOptions(root)];

            const hContainer = document.getElementById('hierarchy-navigator-treeselect');
            hContainer.innerHTML = '';
            hierarchyNavigatorTreeselect = new Treeselect({
                parentHtmlContainer: hContainer,
                options: options,
                value: "", // Single string for single-select mode
                isSingleSelect: true, // As per official single-select example
                isSearchable: true,
                isIndependentNodes: true, // Clicking a parent doesn't select children
                isBranchSelectable: true, // Allow selecting groupings/domains
                placeholder: 'Jump to Control or Domain...',
                clearable: true,
                alwaysOpen: true, // Scrolling list
                showCheckbox: false, // Cleaner look for single-select
                showTags: false, // Don't show removable tags
                staticList: true,
                openLevel: 10, // Don't collapse (fully expanded)
                inputCallback: (value) => {
                    if (!value || Array.isArray(value)) return;
                    const targetNode = root.descendants().find(d => d.id === value);
                    if (targetNode) {
                        window.externalZoom(targetNode);
                        const controlNode = targetNode.ancestors().find(a => a.data.mappings);
                        if (controlNode) {
                            showDetails(controlNode.data);
                        } else {
                            closeDetails();
                        }
                    }
                }
            });
        }

        // --- Filtering Logic ---
        function filterData(data) {
            // Recursive filter
            function recurse(node, depth) {
                // Depth 4 is the new Control Level (Grouping > Applicability > Domain > Control)
                if (depth === 4 || node.mappings) {
                    const regimeGroups = {}; // name -> {name, children}

                    for (const [regimeId, identifiers] of Object.entries(node.mappings || {})) {
                        const rid = parseInt(regimeId);
                        if (selectedRegimeIds.has(rid)) {
                            const regInfo = scfData.regimeList[rid];
                            const rName = regInfo.name;

                            if (!regimeGroups[rName]) {
                                regimeGroups[rName] = {
                                    name: rName,
                                    regimeId: rid,
                                    children: []
                                };
                            }

                            identifiers.forEach(id => {
                                regimeGroups[rName].children.push({
                                    name: id,
                                    regimeId: rid,
                                    value: 1
                                });
                            });
                        }
                    }

                    const validRegimeNodes = Object.values(regimeGroups);

                    // If no mappings match the selected regimes, we still want to show the control, 
                    // just without the regime-specific circles inside it.
                    // (Requirement: Show all controls even if they are not mapped, UNLESS the toggle is off)
                    if (validRegimeNodes.length === 0 && !showUnmapped) return null;

                    return {
                        ...node,
                        children: validRegimeNodes
                    };
                }

                if (node.children) {
                    node.children = node.children.map(c => recurse(c, depth + 1)).filter(c => c !== null);
                    if (node.children.length === 0) return null;
                    return node;
                }
                return node;
            }
            return recurse(data, 0);
        }

        function toggleSidebar() {
            const sidebar = document.getElementById('left-sidebar');
            const icon = document.getElementById('toggle-icon');

            sidebar.classList.toggle('collapsed');

            const isCollapsed = sidebar.classList.contains('collapsed');
            icon.innerText = isCollapsed ? '‚ñ∂' : '‚óÄ';

            // Trigger D3 resize after transition
            setTimeout(() => {
                handleResize();
            }, 400);
        }

        function toggleRightSidebar() {
            document.getElementById('right-sidebar').classList.toggle('open');
            const isOpen = document.getElementById('right-sidebar').classList.contains('open');
            document.getElementById('right-toggle-icon').innerText = isOpen ? '‚ñ∂' : '‚óÄ';

            // Trigger D3 resize to accommodate panel taking up space? 
            // Actually, since it's "fixed" and overlays or pushes from right, we might want to shift the view.
            // D3 is centered in "main", which uses remaining width. We might need to adjust padding-right of main?
            // For now, let it overlay or assume main is flexible. But better to resize.
            const rightWidth = isOpen ? 384 : 0; // w-96 = 24rem = 384px.
            document.querySelector('main').style.marginRight = isOpen ? '384px' : '0';

            setTimeout(() => {
                handleResize();
            }, 400);
        }

        function handleResize() {
            const container = document.getElementById('viz-container');
            if (!container) return;
            width = container.clientWidth;
            height = container.clientHeight;

            if (svg) {
                svg.attr("viewBox", `-${width / 2} -${height / 2} ${width} ${height}`);
                if (root && view) {
                    zoomTo([view[0], view[1], view[2]]); // Refresh current zoom with new dimensions
                }
            }
        }

        window.addEventListener('resize', handleResize);

        function toggleAccordion(id) {
            const content = document.getElementById(id);
            const item = content.parentElement;
            if (content.style.maxHeight && content.style.maxHeight !== "0px") {
                content.style.maxHeight = "0px";
                item.classList.remove('open');
            } else {
                content.style.maxHeight = "500px"; // Fixed max height for scrollability
                item.classList.add('open');
            }
        }

        // --- URL State Management ---
        function updateURL() {
            const params = new URLSearchParams();

            // Regimes (use raw values from Treeselect to keep categories)
            if (window.regimeTreeselect) {
                const val = regimeTreeselect.value;
                if (val && val.length > 0) {
                    params.set('r', val.join(','));
                }
            } else if (selectedRegimeIds.size > 0) {
                params.set('r', Array.from(selectedRegimeIds).join(','));
            }

            // Hierarchy Fields (with aliasing)
            if (processor.currentHierarchy.length > 0) {
                const aliased = processor.currentHierarchy.map(id => HIERARCHY_ALIASES[id] || id);
                params.set('h', aliased.join(','));
            }

            // Unmapped Visibility
            if (showUnmapped) params.set('u', '1');

            // Focus Node
            if (focus && focus !== root) {
                params.set('f', focus.data.name);
            }

            const newHash = params.toString();
            if (window.location.hash.substring(1) !== newHash) {
                window.history.replaceState(null, null, '#' + newHash);
            }
        }

        function applyURLState() {
            const hash = window.location.hash.substring(1);
            if (!hash) return;

            const params = new URLSearchParams(hash);

            // 1. Unmapped Visibility
            if (params.has('u')) {
                showUnmapped = params.get('u') === '1';
                const toggle = document.getElementById('toggle-unmapped');
                if (toggle) toggle.checked = showUnmapped;
            }

            // 2. Hierarchy Fields
            if (params.has('h')) {
                const aliased = params.get('h').split(',');
                const fields = aliased.map(a => REVERSE_ALIASES[a] || a);
                if (fields.length > 0) {
                    processor.currentHierarchy = fields;
                }
            }

            // 3. Regimes
            if (params.has('r')) {
                const rawVals = params.get('r').split(',');
                window._initialRegimeValue = rawVals.map(v => v.startsWith('cat-') ? v : Number(v));
            }
        }

        function applyURLFocus() {
            const hash = window.location.hash.substring(1);
            if (!hash) return;
            const params = new URLSearchParams(hash);
            const focusName = params.get('f');

            if (focusName && root) {
                const target = root.descendants().find(d => d.data.name === focusName);
                if (target) {
                    setTimeout(() => {
                        window.externalZoom(target);
                        if (target.data.mappings) {
                            showDetails(target.data);
                        }
                    }, 500);
                }
            }
        }

        function initTreeselect() {
            const options = Object.keys(scfData.regimeCatalog).sort().map(cat => ({
                name: cat,
                value: `cat-${cat}`,
                children: scfData.regimeCatalog[cat].map(reg => ({
                    name: reg.name,
                    value: reg.id
                }))
            }));

            const container = document.getElementById('treeselect-container');
            regimeTreeselect = new Treeselect({
                parentHtmlContainer: container,
                value: window._initialRegimeValue || Array.from(selectedRegimeIds),
                options: options,
                isMultiple: true,
                isSearchable: true,
                placeholder: 'Search frameworks...',
                clearable: true,
                alwaysOpen: true,
                staticList: true,
                inputCallback: (value) => {
                    const selectedIds = value.reduce((acc, val) => {
                        if (typeof val === 'number') {
                            acc.push(val);
                        } else if (typeof val === 'string' && val.startsWith('cat-')) {
                            const catName = val.replace('cat-', '');
                            const catRegimes = scfData.regimeCatalog[catName];
                            if (catRegimes) catRegimes.forEach(r => acc.push(r.id));
                        }
                        return acc;
                    }, []);

                    selectedRegimeIds = new Set(selectedIds);
                    localStorage.setItem('scf_selected_regimes', JSON.stringify(Array.from(selectedRegimeIds)));
                    updateVisualization();
                    updateLegend();
                    updateURL();
                }
            });

            if (window._initialRegimeValue) {
                const selectedIds = window._initialRegimeValue.reduce((acc, val) => {
                    if (typeof val === 'number') {
                        acc.push(val);
                    } else if (typeof val === 'string' && val.startsWith('cat-')) {
                        const catName = val.replace('cat-', '');
                        const catRegimes = scfData.regimeCatalog[catName];
                        if (catRegimes) catRegimes.forEach(r => acc.push(r.id));
                    }
                    return acc;
                }, []);
                selectedRegimeIds = new Set(selectedIds);
            }
        }


        function initHierarchyFieldsTreeselect() {
            const hContainer = document.getElementById('hierarchy-fields-treeselect');
            if (!hContainer) return;

            const renderWidget = () => {
                hContainer.innerHTML = '';
                const active = processor.currentHierarchy || [];
                const allCols = processor.hierarchyColumns;

                // 1. Active Levels Container
                const activeWrapper = document.createElement('div');
                activeWrapper.className = 'flex flex-col gap-2 mb-4';

                if (active.length > 0) {
                    activeWrapper.innerHTML = '<div class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-1">Active Hierarchy Order</div>';
                    active.forEach((id, index) => {
                        const col = allCols.find(c => c.id === id);
                        if (!col) return;

                        const item = document.createElement('div');
                        item.className = 'flex items-center justify-between bg-blue-500/10 border border-blue-500/20 text-blue-300 px-3 py-2 rounded text-xs select-none hover:bg-blue-500/20 transition-colors group cursor-pointer';
                        item.innerHTML = `
                            <div class="flex items-center gap-2">
                                <span class="font-mono opacity-50 text-[10px]">${index + 1}</span>
                                <span class="font-bold">${col.name}</span>
                            </div>
                            <span class="text-xs opacity-50 group-hover:opacity-100 group-hover:text-red-400 transition-opacity">‚úï</span>
                        `;
                        item.onclick = () => {
                            // Remove this item
                            processor.currentHierarchy.splice(index, 1);
                            updateState();
                        };
                        activeWrapper.appendChild(item);
                    });
                } else {
                    activeWrapper.innerHTML = '<div class="text-xs text-gray-500 italic p-2 text-center border border-dashed border-white/10 rounded">No hierarchy levels selected.<br>Select fields below to start.</div>';
                }
                hContainer.appendChild(activeWrapper);

                // 2. Available Fields Container
                const availWrapper = document.createElement('div');
                availWrapper.className = 'flex flex-wrap gap-2';
                availWrapper.innerHTML = '<div class="w-full text-[10px] font-bold text-gray-500 uppercase tracking-widest mb-1">Available Fields</div>';

                const available = allCols.filter(c => !active.includes(c.id));

                if (available.length === 0) {
                    availWrapper.innerHTML += '<div class="text-xs text-gray-600 italic">All fields selected.</div>';
                }

                available.forEach(col => {
                    const btn = document.createElement('button');
                    btn.className = 'bg-white/5 hover:bg-white/10 text-gray-400 hover:text-white px-2 py-1 rounded text-xs border border-white/5 transition-colors text-left';
                    btn.innerText = col.name;
                    btn.onclick = () => {
                        // Add to end
                        processor.currentHierarchy.push(col.id);
                        updateState();
                    };
                    availWrapper.appendChild(btn);
                });
                hContainer.appendChild(availWrapper);
            };

            const updateState = () => {
                scfData = processor.buildTree(processor.currentHierarchy);
                updateVisualization();
                updateURL();
                setTimeout(initHierarchyNavigatorTreeselect, 50);
                renderWidget(); // Re-render self
            };

            renderWidget();
        }

        function initHierarchyNavigatorTreeselect() {
            const hContainer = document.getElementById('hierarchy-navigator-treeselect');
            if (!hContainer) return;
            hContainer.innerHTML = '';

            // Helper to recursively build nested options
            function buildNestedOptions(node) {
                if (!node) return [];
                const option = {
                    name: node.data.name,
                    value: node.id,
                    node: node, // reference for zoom
                    children: []
                };

                if (node.children) {
                    option.children = node.children.map(child => buildNestedOptions(child)).flat();
                } else {
                    delete option.children; // Leaf node
                }
                return option;
            }

            // Build options starting from root's children (skipping the abstract root if needed)
            // If root is abstract, map its children. If root is actual data, wrap it.
            let nestedOptions = [];
            if (root) {
                if (root.children) {
                    nestedOptions = root.children.map(child => buildNestedOptions(child)).flat();
                } else {
                    nestedOptions = [buildNestedOptions(root)];
                }
            }

            hierarchyNavigatorTreeselect = new Treeselect({
                parentHtmlContainer: hContainer,
                options: nestedOptions,
                value: null, // Single value (null) for single select
                isSingleSelect: true,
                isSearchable: true,
                placeholder: 'Jump to Control or Domain...',
                clearable: true,
                alwaysOpen: true,     // Keep it open as a navigator
                staticList: true,     // Render in-place
                showCheckbox: false,  // NO checkboxes for single select
                disableBranchNodes: false, // Allow selecting branches (domains) to zoom to them
                expandSelected: true,
                inputCallback: (value) => {
                    if (!value) return;
                    // Find node in D3 hierarchy by ID since we can't easily flatten the nested structure in O(1)
                    // But we can use the D3 root.descendants() map we already have implicitly
                    const targetNode = root.descendants().find(d => d.id === value);

                    if (targetNode) {
                        window.externalZoom(targetNode);
                        if (targetNode.data.mappings) {
                            showDetails(targetNode.data);
                        }
                    }
                }
            });
        }

        function toggleUnmappedVisibility(checked) {
            showUnmapped = checked;
            updateVisualization();
            updateURL();
        }

        function updateLegend() {
            const container = document.getElementById('regime-legend');
            container.innerHTML = '';

            selectedRegimeIds.forEach(rid => {
                const reg = scfData.regimeList[rid];
                if (!reg) return;
                const item = document.createElement('div');
                item.className = 'bg-black/60 backdrop-blur px-3 py-1.5 rounded-full border border-white/10 flex items-center gap-2 shadow-xl';
                item.innerHTML = `
                    <div class="w-2 h-2 rounded-full" style="background: ${getRegimeColor(rid)}"></div>
                    <span class="text-[9px] font-bold text-white uppercase tracking-wider">${reg.name}</span>
                `;
                container.appendChild(item);
            });
        }

        function showDetails(data) {
            if (!data || !data.mappings) return; // Only show for controls

            // Safe helper to set text if element exists
            const safeSetText = (id, text) => {
                const el = document.getElementById(id);
                if (el) el.innerText = text;
            };

            safeSetText('detail-id', data.name.split(':')[0]);
            safeSetText('detail-title', data.name.split(':')[1]?.trim() || data.name);
            safeSetText('detail-desc', data.description || "No description provided.");
            safeSetText('detail-weight', data.weight || "1.0");

            // Format PPTDF
            const pptdf = Object.keys(HIERARCHY_ALIASES).find(key => data[key]) || "Unspecified";
            safeSetText('detail-pptdf', pptdf.replace(/_/g, ' '));

            // Map Mappings
            const mapContainer = document.getElementById('detail-mappings');
            // Proceed only if container exists in DOM
            if (mapContainer) {
                mapContainer.innerHTML = '';

                const mappings = data.mappings || {};
                let hasMappings = false;

                Object.entries(mappings).forEach(([rid, ids]) => {
                    hasMappings = true;
                    const rInfo = scfData.regimeList[rid];
                    if (!rInfo || !selectedRegimeIds.has(parseInt(rid))) return;

                    const el = document.createElement('div');
                    el.className = 'bg-white/5 rounded-lg p-3 border border-white/5';
                    el.innerHTML = `
                        <div class="flex items-center gap-2 mb-2">
                             <div class="w-2 h-2 rounded-full" style="background: ${getRegimeColor(rid)}"></div>
                             <span class="text-[10px] font-bold text-gray-400 uppercase tracking-widest">${rInfo.name}</span>
                        </div>
                        <div class="flex flex-wrap gap-2">
                            ${ids.map(id => `<span class="text-xs bg-black/40 px-2 py-1 rounded border border-white/10 text-gray-300 font-mono">${id}</span>`).join('')}
                        </div>
                    `;
                    mapContainer.appendChild(el);
                });

                if (!hasMappings) {
                    mapContainer.innerHTML = '<div class="text-xs text-gray-600 italic p-2 dark:text-gray-500">No active mappings for selected regimes.</div>';
                }
            }

            // Show Details Section
            const dEmpty = document.getElementById('detail-empty');
            const dData = document.getElementById('detail-data');
            if (dEmpty) dEmpty.classList.add('hidden');
            if (dData) dData.classList.remove('hidden');

            // Open right sidebar if closed
            const rightSidebar = document.getElementById('right-sidebar');
            if (rightSidebar && !rightSidebar.classList.contains('open')) {
                toggleRightSidebar();
            }
        }

        function closeDetails() {
            const dEmpty = document.getElementById('detail-empty');
            const dData = document.getElementById('detail-data');
            if (dEmpty) dEmpty.classList.remove('hidden');
            if (dData) dData.classList.add('hidden');
        }

        function updateLabelDepth(val) {
            labelDetailLevels = parseInt(val);
            localStorage.setItem('scf_label_depth', val);
            document.getElementById('label-depth-val').innerText = `${val} Level${val > 1 ? 's' : ''}`;

            // Instantly update existing labels
            label.transition().duration(400)
                .style("fill-opacity", d => getLabelOpacity(d, focus))
                .style("display", d => getLabelDisplay(d, focus));
        }

        function updateBreadcrumbs(d) {
            const crumb = document.getElementById('breadcrumbs');
            if (!d) return;

            const ancestors = d.ancestors().reverse();
            crumb.innerHTML = ''; // Clear existing

            ancestors.forEach((node, index) => {
                const isLast = index === ancestors.length - 1;
                const span = document.createElement('span');
                span.textContent = node.data.name.split(':')[0];
                span.className = isLast ? "font-bold text-slate-900 dark:text-white" : "cursor-pointer hover:text-blue-500 transition-colors duration-200 text-slate-500 dark:text-slate-400";

                if (!isLast) {
                    span.onclick = (e) => {
                        e.stopPropagation();
                        zoom(e, node);
                    };
                }

                crumb.appendChild(span);

                if (!isLast) {
                    const separator = document.createElement('span');
                    separator.className = "mx-1 opacity-30 text-gray-500 dark:text-gray-400";
                    separator.textContent = "/";
                    crumb.appendChild(separator);
                }
            });
        }

        // --- Theme Management ---
        window.setTheme = (theme) => {
            localStorage.setItem('scf_theme', theme);

            if (theme === 'dark' || (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }

            // Update select if implementation logic changed it
            const sel = document.getElementById('theme-select');
            if (sel) sel.value = theme;
        };

        // Initial Theme Load
        const storedTheme = localStorage.getItem('scf_theme') || 'system';
        setTheme(storedTheme);

        // Listen for system changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
            if (localStorage.getItem('scf_theme') === 'system') {
                setTheme('system');
            }
        });

        // --- Initialization ---
        window.addEventListener('load', async () => {
            try {
                applyURLState(); // Load state from URL first

                // Initialize Processor with potentially overridden hierarchy
                scfData = await processor.init('data/scf_controls.csv', 'data/scf_domains.csv');

                initViz();
                initTreeselect();
                initHierarchyFieldsTreeselect();
                initHierarchyNavigatorTreeselect();

                updateLegend();
                applyURLFocus();
            } catch (error) {
                console.error("Failed to initialize SCF Visualizer:", error);
                alert("Error loading SCF data. Please ensure CSV files are accessible.");
            }
        });

    </script>
</body>

</html>